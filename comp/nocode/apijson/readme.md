# APIJSON SDK 深度开发者手册 (v1.0)

## 1.0 核心概念

- ### **1.1 请求/响应结构**
    > SDK 遵循标准的 APIJSON 模式，即客户端发送一个描述操作的 JSON 对象，服务端返回一个 JSON 对象，其顶层键与请求中的操作键相对应。

- ### **1.2 单对象 vs. 列表 (`User` vs `User[]`)**
    - **语法说明**: 这是 APIJSON 中一个至关重要的约定。
        - **不带 `[]` (例如 `"User"`)**: 表示你预期操作或返回**单个对象**。即使查询匹配到多条记录，也只返回第一条。
        - **带 `[]` (例如 `"User[]"`)**: 表示你预期操作或返回一个**对象数组**。查询操作会返回所有匹配的记录（受分页限制）。
    - **适用范围**: 这个约定主要用于 `GET` 查询，但在 `POST`、`PUT` 等操作中也有影响，用于区分是操作单条还是批量数据。

## 2.0 查询数据 (GET)

- ### **2.1 基础查询**
    - #### 2.1.1 查询单条记录
        - **语法说明**: 使用不带 `[]` 的表名作为 Key。
        - **语法示例 (获取 ID 为 1 的用户)**:
            ```json
            {
                "User": { "id": 1 }
            }
            ```
        - **成功响应**:
            ```json
            {
                "User": {
                    "id": 1,
                    "name": "Alice",
                    ...
                }
            }
            ```
    - #### 2.1.2 查询记录列表
        - **语法说明**: 使用带 `[]` 的表名作为 Key。
        - **语法示例 (获取所有状态为 1 的用户)**:
            ```json
            {
                "User[]": { "status": 1 }
            }
            ```
        - **成功响应**:
            ```json
            {
                "User[]": [
                    { "id": 1, "name": "Alice", ... },
                    { "id": 2, "name": "Bob", ... }
                ]
            }
            ```

- ### **2.2 返回字段控制 (`@column`)**
    - #### 语法说明
        > 使用 `@column` 关键字，提供一个以英文逗号分隔的字符串，精确指定返回的字段。若不提供，则默认为 `*` (所有字段)。
    - #### 语法示例 (只获取用户的 ID、姓名和头像):
        ```json
        {
            "User": {
                "id": 1,
                "@column": "id,name,avatar"
            }
        }
        ```

- ### **2.3 排序 (`@order`)**
    - #### 语法说明
        > 对结果集进行排序。支持多字段、多方向排序。
    - #### 所有可用语法
        - **单字段升序 (默认)**: `"@order": "id"`
        - **单字段升序 (显式)**: `"@order": "id ASC"`
        - **单字段降序**: `"@order": "id DESC"`
        - **多字段组合排序**: `"@order": "level DESC, create_time DESC"`
    - #### 语法示例 (按等级降序、创建时间降序排序):
        ```json
        {
            "User[]": {
                "@order": "level DESC, create_time DESC"
            }
        }
        ```

- ### **2.4 分页 (`@page`, `@limit`)**
    - #### 语法说明
        > - `@limit`: 每页返回的记录数。
        > - `@page`: 查询的页码，**从 0 开始**。`@page: 0` 是第一页。
        > SDK 内部转换逻辑: `OFFSET = page * limit`。
    - #### 语法示例 (获取用户列表的第 3 页，每页 15 条):
        ```json
        {
            "User[]": {
                "@page": 2,
                "@limit": 15,
                "@order": "id DESC"
            }
        }
        ```

- ### **2.5 条件过滤 (`WHERE` 子句)**
    > 这是查询最核心的部分，由统一的 `WhereParserHandle` 递归解析。
    - #### 2.5.1 值比较操作符
        - **等于 `=`**: `{"key": "value"}`
        - **不等于 `!=`**: `{"key!=": "value"}`
        - **大于 `>`**: `{"key>": 100}`
        - **大于等于 `>=`**: `{"key>=": 100}`
        - **小于 `<`**: `{"key<": 100}`
        - **小于等于 `<=`**: `{"key<=": 100}`
    - #### 2.5.2 集合/范围操作符
        - **`IN (...)`**: `{"key{}": [1, 2, 3]}`
        - **`NOT IN (...)`**: `{"key!{}": [4, 5, 6]}`
    - #### 2.5.3 模糊匹配操作符
        - **`LIKE '%value%'`**: `{"key$": "keyword"}` (SDK 自动在两边加 `%`)
        - **`REGEXP`**: `{"key%": "^start-of-string"}`
    - #### 2.5.4 逻辑操作符
        - **`OR` (简单形式)**: 使用 `|` 连接多个字段，表示它们之间是 `OR` 关系。
            - **示例**: `WHERE phone = '12345' OR email = '12345'`
                ```json
                { "phone|email": "12345" }
                ```
        - **`AND` / `OR` (复杂组合)**: 使用 `{"@": { ... }}` 结构进行任意层级的嵌套。
            - **示例**: `WHERE (status = 1 AND (level > 5 OR name LIKE '%VIP%')) OR id IN (1, 2, 3)`
                ```json
                {
                    "@": {
                        "operator": "OR",
                        "id{}": [1, 2, 3],
                        "AND": {
                            "status": 1,
                            "OR": {
                                "level{>}": 5,
                                "name$": "VIP"
                            }
                        }
                    }
                }
                ```

- ### **2.6 组合查询示例**
    - #### 需求
        > 查询所有已激活 (`status = 1`) 的女性 (`gender = 2`) 用户中，等级最高的前 10 位，并只返回她们的 ID、姓名和等级。
    - #### 完整示例
        ```json
        {
            "User[]": {
                "status": 1,
                "gender": 2,
                "@column": "id,name,level",
                "@order": "level DESC",
                "@limit": 10,
                "@page": 0
            }
        }
        ```

## 3.0 新增数据 (POST)

- ### **3.1 单记录新增**
    - #### 语法说明
        > 请求体中的 Key 为表名，Value 为要插入的数据对象。
    - #### 语法示例
        ```json
        {
            "User": { "name": "Charlie", "gender": 1 }
        }
        ```
    - #### 成功响应
        > 返回新纪录的 `id` 和 `count`。
        ```json
        {
            "User": { "id": 123, "count": 1 }
        }
        ```

- ### **3.2 嵌套新增 (一对多)**
    - #### 语法说明
        > 在主表数据中，以**大写驼峰式**的子表名作为 Key。整个操作包裹在**数据库事务**中。
    - #### 命名约定 (重要)
        > 子表用于存储父表ID的外键，其字段名必须遵循 `小写下划线主表名_id` 的格式。
        > - 主表 `User` -> 子表外键 `user_id`
        > - 主表 `UserMoment` -> 子表外键 `user_moment_id`
    - #### 语法示例 (新增用户，并同时为他新增一条动态和一条登录日志)
        ```json
        {
            "User": {
                "name": "David",
                "gender": 1,
                "Moment": {
                    "content": "Just registered! So excited!"
                },
                "LoginLog": {
                    "ip": "127.0.0.1",
                    "type": "register"
                }
            }
        }
        ```
    - #### 成功响应 (嵌套结构)
        ```json
        {
            "User": {
                "id": 124,
                "count": 1,
                "Moment": { "id": 501, "count": 1 },
                "LoginLog": { "id": 1025, "count": 1 }
            }
        }
        ```

## 4.0 更新数据 (PUT)

- ### **4.1 按条件批量更新**
    - #### 语法说明
        > 在同一 JSON 层级提供 `WHERE` 条件和 `SET` 数据。`WHERE` 条件支持所有高级查询语法。
    - #### 安全机制
        > - **必须包含 `WHERE`**: 为防止全表更新，请求中必须至少包含一个 `WHERE` 条件。
        - **字段智能分离**: SDK 会自动识别用作 `WHERE` 的字段，并将它们从 `SET` 数据中剔除。
    - #### 语法示例 (为所有 ID 大于 100 的用户增加等级，并更新状态)
        ```json
        {
            "User": {
                "id{>}": 100,
                "level": 5,
                "status": 1
            }
        }
        ```
        > **SQL 等价于**: `UPDATE User SET level = 5, status = 1 WHERE id > 100`
    - #### 成功响应
        > 返回 `ok` 状态和受影响的行数 `count`。
        ```json
        {
            "User": { "ok": true, "count": 10 }
        }
        ```

## 5.0 删除数据 (DELETE)

- ### **5.1 按条件批量删除**
    - #### 语法说明
        > 提供 `WHERE` 条件来匹配需要删除的记录。支持所有高级查询语法。
    - #### 安全机制
        > **必须包含 `WHERE`**: 为防止全表删除，请求中必须至少包含一个 `WHERE` 条件。
    - #### 语法示例 (删除所有注册超过一年且从未登录的用户)
        ```json
        {
            "User": {
                "create_time{<}": "2022-01-01 00:00:00",
                "login_times": 0
            }
        }
        ```
    - #### 成功响应
        > 返回 `ok` 状态和被删除的行数 `count`。
        ```json
        {
            "User": { "ok": true, "count": 5 }
        }
        ```

## 6.0 高级功能

- ### **6.1 自定义函数 (`@func`)**
    - #### 语法说明
        > 安全地调用白名单内的 SQL 函数。`key` 作为别名，`value` 是函数表达式。参数可以是**字段名**或**字面量**（字符串需加引号）。
    - #### 白名单
        > `NOW`, `COUNT`, `SUM`, `AVG`, `MAX`, `MIN`, `CONCAT`
    - #### 语法示例
        ```json
        {
            "User[]": {
                "id{}": [1,2,3],
                "@column": "id,name",
                "@func": {
                    "now": "NOW()",
                    "total": "SUM(level)",
                    "user_info": "CONCAT(name, ':', level)"
                }
            }
        }
        ```

- ### **6.2 分组与聚合 (`@group`, `@having`)**
    - #### 语法说明
        > `@group` 指定分组字段，`@having` 对分组后的结果进行过滤。
    - #### 语法示例 (按性别分组，统计每组的总等级数，并只显示总等级数大于 1000 的组)
        ```json
        {
            "User[]": {
                "@column": "gender, SUM(level) as total_level",
                "@group": "gender",
                "@having": "total_level > 1000"
            }
        }
        ```

## 7.0 校验与安全

- ### **7.1 字段存在性校验 (`@must`, `@refuse`)**
    - **`@must`**: 数组内的字段必须存在。
        - **示例**: `{"User": {"name": "Test"}, "@must": ["name", "email"]}}` -> **失败**
    - **`@refuse`**: 数组内的字段禁止存在。
        - **示例**: `{"User": {"name": "Test", "role": "admin"}, "@refuse": ["role"]}}` -> **失败**

- ### **7.2 严格模式 (`@strict`)**
    - #### 语法说明
        > 设置 `"@strict": true` 后，请求中的所有业务字段都必须在 `@must` 或 `@refuse` 中声明。
    - #### 语法示例
        ```json
        {
            "User": {
                "name": "Test",
                "phone": "12345",
                "@strict": true,
                "@must": ["name"]
            }
        }
        ```
        > **结果**: **失败**，因为 `phone` 字段未在 `@must` 或 `@refuse` 中声明。

- ### **7.3 SQL 注入防护**
    - #### 语法说明
        > 内置特性，自动生效。所有用户输入的值都会通过 **PDO 参数绑定** 进行处理，从根本上杜绝了 SQL 注入的风险。 